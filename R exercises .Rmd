---
title: "Homework Assignment 12 (100 + 10 bonus points)"
author: ""
date: ""
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Write your solutions and comments in this markdown file and submit it with its pdf version to moodle.  

Write all the libraries you are using here:
```{r}
library(stringr)
library(dplyr)
library(ggplot2)
```


## Regex Patterns (100 + 10 points)

**1.1. Consider the vector of character texts given below. Make all the texts to upper case. (6 point)**
```{r}
txts <- c("R", "is", "a", "Programming", "language", "and", "Free", "Software", "environment", "for", "Statistical", "computing")

toupper(txts)
```

**1.2. Create a function, which will get an input a text character vector, and using *str_sub* and *toupper* functions make the first character of each word uppercase. The function should return a sentence from this words. Run it on the above example *txts*. (10 points)**  
A small example: input - c("I", "want", "to", "go"), output - "I Want To Go"

```{r}
get_upper_sentence <- function(texts) {
  res <- ""
  for (text in texts) {
    first_letter <- str_sub(text, start=1, end=1)
    others <- str_sub(text, start=2, end=-1)
    word <- paste0(toupper(first_letter), others)
    res <- paste(res, word)
  }
  return (str_trim(res))
}
get_upper_sentence(txts)
```

**1.3. Create a pattern that checks in *text_1* if there is a lowercase character followed by any character (that is letter, digit, symbol, anything) and then by a digit. Use *str_detect*. (8 points)**
A small example: "4aB7" - True as there is 'aB7' pattern satisfying to condition, "3aBC" - False

```{r}
text_1 <- c("asdf123", "rand3R.", "aAA434", "String2")

str_detect(text_1, pattern="[a-z].[0-9]")
```

**1.4. Using regex find a pattern that will match the exact string of "?^?". Use detecting or subseting function of stringr. (8 points)**

```{r}
example <- c("-as?^?as", "?^?12", "thisnot?")

str_detect(example, pattern = "\\?\\^\\?")
```


**1.5. Replace all " 1 " characters that are not part of a longer number or part of a word (not "14", "1991", "covid19", but "1 time" -> "one time") in the strings below by " one ". In other words you have to replace all 1-s that have nothing by their sides (symbol, other numbers) by "one". (8 points)**   
A small example: "All in 1 piece: safely." -> "All in one piece: safely."

```{r}
text_2 <- c("All in 1 breath: said of something spoken excitedly without pause." ,
            "All in 1 piece: safely.", 
            "At the age of 19 months, children was learning to talk.",
            "All rolled up in 1 combined.",
            "All-in-one with all required features.", 
            "It is difficult age: from 14 to 19.",
            "State advises citizens to reconsider traveling due to impact of covid19.",
            "As 1 as if a group were 1 entity.")

text_2_fixed <- str_replace_all(text_2, pattern="\\s1\\s", replacement=" one ")
text_2_fixed
```



**1.6. Create a function, which will get an input a text character vector, where there should be phone numbers. The function should extract all numbers that are valid Armenian numbers (check that it starts with 0 and does not have letters in it and number of digits is 9: that is enough), bring all valid numbers to one format (either with "-"s or without, either with spaces or without). Run your function on the example *phone_numbers*. (10 points)**

```{r}
phone_numbers <- c("091-234931", "5214698", "a033255687", "077-45-89-96", "256347077", "047155266", "05523365d", "096900611", "096-900611", "11008005", "077 33 70 91")

get_formatted_numbers <- function(txts) {
  # First subset not to have any numbers with letters
  txts <- txts[!str_detect(txts, "[a-zA-z]")]
  # Delete all -s and spaces
  txts <- str_replace_all(txts, "-|\\s+", "")
  # subset by length and starting with 0 
  txts <- txts[nchar(txts) == 9 & str_sub(txts, start=1, end=1)=="0"]
  
  return (txts)
}

formatted_phone_numbers <- get_formatted_numbers(phone_numbers)
formatted_phone_numbers
```

**1.7. Having the result of previous exercise, count how many phone numbers belong to Beeline company, if the codes for Beeline company are "091", "099", "047", "043", "096". Create your pattern with the existing vector *beeline_codes* below? (8 points)**      
Hint: Look at *paste0* function and its arguments, there should be 2. Which one you need? 

```{r}
beeline_codes <- c("091", "099", "047", "043", "096")

pattern <- paste0("^", beeline_codes)
pattern <- paste0(pattern, collapse="|")

beeline_count <- sum(str_count(formatted_phone_numbers, pattern=pattern))
beeline_count
```


**1.8. Create a function that will get an input a character vector, and using whitespaces that can be added through BOTH ends of string, make the length of each string in the vector to be equal to the longest string in the vector. Run your function in any example. (6 points)**  
A small example: if function gets as an input c("I", "am", "happy"), it should output c("  I  ", " am  ", "happy") (all strings have length of 5, as the longest word "happy").   

Hint: Use google to find function/s that can be used for this. What about *str_pad* and *str_trim*? Which do you need?

```{r}
pad_to_longest <- function(input_vector){
  lengths <- nchar((input_vector))
  longest = max(lengths)
  result = str_pad(input_vector, width=longest, side='both')
  return (result)
}

pad_to_longest(c("I", "am", "happy"))
```


**1.9. Write a regex pattern that given a character vector and desired_length, will return subsetted vector containing only those strings that are the same length as the desired length. Do NOT use *nchar* function in your code. Use regex. (10 points)**

```{r}
input_vector <- c("what", "is", "your", "problem", "with", "so", "many", "words")
desired_length <- 4

pattern_letters <- paste0(rep(".", desired_length), collapse = "")
pattern <- paste0("^", pattern_letters, "$")

str_subset(input_vector, pattern = pattern)
```


**1.10. Do the same thing as in previous exercise, but find all words that have length >= desired_length. (8 points)**

```{r}
str_subset(input_vector, pattern = pattern_letters)
```

**1.11. Given the vector below, write two regex patterns and subset the initial vector two times. First find only words that have ONLY consonant letters in it. Secondly find the words that end in "ing" but not in "iing". (16 points)**
```{r}
given_vector <- c("try", "monoskiing", "to", "do", "paraskiing", "freeskiing", "the", "right", "thing", "gym", "why", "cry", "wing")
```

```{r}
str_subset(given_vector, pattern="[aeiou]", negate=TRUE)
```
```{r}
str_subset(given_vector, pattern="[^i]ing$")
```


**1.12 Subset the vector to have only those words, that contain two or more consonant-vowel pairs. (12 points)**
A small example: along - does not satisfy, there is only one pair of consanant-vowel pair "lo".  
A small example: active - satisfies, contains "ti", "ve".  

```{r}
words <- c("along", "active", "advertise", "become", "away", "ever", "exist", "eleven")
str_subset(words, pattern = "([^aeiou][aeiou]){2,}")
```





